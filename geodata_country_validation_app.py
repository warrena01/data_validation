{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "7befb401",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tkinter\n",
    "from tkinter import filedialog, messagebox\n",
    "from tkinter import ttk\n",
    "import geopandas as gpd\n",
    "import pandas as pd\n",
    "import folium\n",
    "from shapely.geometry import Point\n",
    "import openpyxl\n",
    "from folium.plugins import HeatMap, MarkerCluster\n",
    "from os import path\n",
    "\n",
    "# intiate global variables\n",
    "data = None # this will hold the excel workfile\n",
    "shapefile_low_res = None # this will hold the shapefile at a low resolution\n",
    "shapefile_high_res = None # this will hold the shapefile at a high resolution\n",
    "country_name = None # this will hold the variable that names the country \n",
    "map_output = None # this will hold the map output wanted \n",
    "file_name = None # this will hold the file name they want to save it as \n",
    "file_path = None # this will hold the path link to the new file\n",
    "\n",
    "def get_excel_doc():\n",
    "    global data \n",
    "    root = tkinter.Tk()\n",
    "    excel_doc = filedialog.askopenfilename()\n",
    "    root.withdraw()\n",
    "    if excel_doc.split(\".\")[-1] in [\"xlsx\", \"xls\"]:\n",
    "        data_1 = pd.read_excel(excel_doc)\n",
    "        data_1.columns = ['ID', 'latitude', 'longitude']\n",
    "        data = data_1\n",
    "    else:\n",
    "        messagebox.showerror(title=\"file type error\", message=\"you chose the wrong file type, try again.\")\n",
    "\n",
    "def get_shp_1():\n",
    "    global shapefile_low_res\n",
    "    root = tkinter.Tk()\n",
    "    my_file_path = filedialog.askopenfilename()\n",
    "    root.withdraw()\n",
    "    if my_file_path.split(\".\")[-1] in [\"shp\"]:\n",
    "        shapefile_low_res = my_file_path\n",
    "    else:\n",
    "        messagebox.showerror(title=\"file type error\", message=\"you chose the wrong file type, try again.\")\n",
    "        \n",
    "def get_shp_2():\n",
    "    global shapefile_high_res\n",
    "    root = tkinter.Tk()\n",
    "    my_file_path = filedialog.askopenfilename()\n",
    "    root.withdraw()\n",
    "    if my_file_path.split(\".\")[-1] in [\"shp\"]:\n",
    "        shapefile_high_res = my_file_path\n",
    "    else:\n",
    "        messagebox.showerror(title=\"file type error\", message=\"you chose the wrong file type, try again.\")\n",
    "\n",
    "def choose_country():\n",
    "    global country_name, progress_value\n",
    "    selected_indices = listbox.curselection()\n",
    "    if selected_indices:\n",
    "        index = selected_indices[0]  # Assuming you expect only one selection\n",
    "        country_name = listbox.get(index)\n",
    "        \n",
    "def choose_output():\n",
    "    global map_output\n",
    "    selected_indices = listbox2.curselection()\n",
    "    if selected_indices:\n",
    "        index = selected_indices[0]  # Assuming you expect only one selection\n",
    "        map_output = listbox2.get(index)\n",
    "        \n",
    "def get_file_name():\n",
    "    global file_name, task_completed\n",
    "    text = textentry_file.get()\n",
    "    file_name = text\n",
    "\n",
    "def get_file_path():\n",
    "    global file_path\n",
    "    root = tkinter.Tk()\n",
    "    my_file_path = filedialog.askdirectory()\n",
    "    root.withdraw()\n",
    "    my_file_path = str(my_file_path) + '/' + str(file_name) + '.html'\n",
    "    file_path = my_file_path\n",
    "    \n",
    "def finished_tasks():\n",
    "    global file_path\n",
    "    if path.exists(file_path):\n",
    "            messagebox.showinfo(title=\"task completed\", message=\"All tasks are completed, you can now close all windows\")\n",
    "        \n",
    "def plot_maps(data, country_geometry_high_res, map_output, inside, outside_high_res, inside_count, file_path, country_geometry_low_res): \n",
    "    \n",
    "    map_plot = folium.Map(location=[data['latitude'].mean(), data['longitude'].mean()], zoom_starts=4, tiles='CartoDB positron')\n",
    "    country_geojson = country_geometry_high_res.__geo_interface__\n",
    "    folium.GeoJson(country_geojson, name='Country Boundary',style_function=lambda feature:{\n",
    "                        'fillColor': 'lightyellow',\n",
    "                        'color': 'black',\n",
    "                        'weight': 1,\n",
    "                        'fillOpacity': 0.3,      \n",
    "                        }\n",
    "                      ).add_to(map_plot)\n",
    "    \n",
    "    heat_data = [[row['latitude'], row['longitude']] for index, row in data.iterrows() if Point(row['longitude'], row['latitude']).within(country_geometry_low_res)]\n",
    "    marker_cluster = folium.plugins.MarkerCluster(name=\"Coordinate Points\", options={'disableClusteringAtZoom':10},show=False).add_to(map_plot)\n",
    "\n",
    "    #overlay group\n",
    "    overlay_group = folium.FeatureGroup(name='Overlay Layers',show=False)\n",
    "    overlay_group.add_to(map_plot)\n",
    "\n",
    "    if map_output == 'Heatmap':\n",
    "        HeatMap(heat_data,name=\"HeatMap\", show = False).add_to(map_plot)\n",
    "\n",
    "    elif map_output == 'Heatmap Overlay':\n",
    "        HeatMap(heat_data,name=\"HeatMap\", show = False).add_to(map_plot)\n",
    "        for lat_long,count in inside_count.items():\n",
    "            folium.Circle(lat_long,popup={lat_long},\n",
    "                            radius=count*5, color ='black', fill=True,fill_opacity=0.5).add_to(overlay_group)\n",
    "\n",
    "    elif map_output == 'Point Data Map':\n",
    "        for lat_long,count in inside_count.items():\n",
    "            folium.Marker(lat_long,popup=f\"Inside Boundaries<br>{lat_long}\",\n",
    "                            icon=folium.Icon(color='green')).add_to(marker_cluster)\n",
    "            folium.Circle(lat_long,popup={lat_long},\n",
    "                            radius=count*5, color ='black', fill=True, fill_opacity=0.5).add_to(overlay_group)\n",
    "    else:\n",
    "        HeatMap(heat_data, name=\"HeatMap\", show = False).add_to(map_plot)\n",
    "        for lat_long,count in inside_count.items():\n",
    "            folium.Marker(lat_long,popup=f\"Inside Boundaries<br>{lat_long}\",\n",
    "                            icon=folium.Icon(color='green')).add_to(marker_cluster)\n",
    "            folium.Circle(lat_long,popup={lat_long},\n",
    "                            radius=count*5, color ='black', fill=True, fill_opacity=0.5).add_to(overlay_group)\n",
    "\n",
    "    for ID,lat,lon in outside_high_res:\n",
    "        folium.Marker(location=[lat,lon], popup=f\"Outside Boundaries<br>ID:{ID}<br>{lat}<br>{lon}\",\n",
    "                            icon=folium.Icon(color='red')).add_to(map_plot)\n",
    "\n",
    "    # Adding legend for differentiating Inside and Outside coordinate points\n",
    "    legend_html = \"\"\"\n",
    "        <div style=\"position: fixed; bottom:30px; right:30px; z-index:9999; font-size:11px;\">\n",
    "            <p><i class=\"fa fa-circle fa-1x\" style=\"color:green\"></i> Inside Boundary</p>\n",
    "            <p><i class=\"fa fa-circle fa-1x\" style=\"color:red\"></i> Outside Boundary</p>\n",
    "        </div>\n",
    "        \"\"\"\n",
    "    map_plot.get_root().html.add_child(folium.Element(legend_html))\n",
    "\n",
    "    # Adding various tiles option incoorporated within Folium library\n",
    "    folium.TileLayer('CartoDB positron').add_to(map_plot) #Selected as Default\n",
    "    folium.TileLayer('OpenStreetMap').add_to(map_plot) \n",
    "    folium.TileLayer('Stamen Terrain').add_to(map_plot)\n",
    "    folium.TileLayer('Stamen Toner').add_to(map_plot)\n",
    "    folium.TileLayer('esrinatgeoworldmap', name='Esri NatGeo WorldMap', attr=' Esri, Delorme, NAVTEQ').add_to(map_plot)\n",
    "\n",
    "    # Full Screen option\n",
    "    folium.plugins.Fullscreen().add_to(map_plot)\n",
    "\n",
    "    # Layer control for each layers added can be checked & unchecked while selecting\n",
    "    folium.LayerControl(position='topright',collapsed=True, autoZIndex=True).add_to(map_plot)\n",
    "\n",
    "    # Saved the outputs\n",
    "    map_plot.save(file_path)  \n",
    "    \n",
    "    finished_tasks()\n",
    "    \n",
    "def geospatial_analysis():\n",
    "    global data, shapefile_low_res, shapefile_high_res, country_name, map_output, file_name, file_path\n",
    "    \n",
    "    counter = 0\n",
    "    my_list = [data, shapefile_low_res, shapefile_high_res, country_name, map_output, file_name, file_path]\n",
    "    for i in my_list:\n",
    "        if (i is None):\n",
    "            counter += 1\n",
    "            break\n",
    "        else:\n",
    "            continue\n",
    "        \n",
    "    if counter == 0:\n",
    "    \n",
    "        # get the shapefiles\n",
    "        gdf_low_res = gpd.read_file(shapefile_low_res)\n",
    "        gdf_high_res = gpd.read_file(shapefile_high_res)\n",
    "\n",
    "        # isolate the geometries\n",
    "        country_gdf_low_res = gdf_low_res.loc[gdf_low_res['NAME'] == country_name] # isolate row\n",
    "        country_geometry_low_res = country_gdf_low_res.geometry.iloc[0] # get multipolygon\n",
    "        country_geometry_buffer = country_geometry_low_res.buffer(-0.15)\n",
    "        country_gdf_high_res = gdf_high_res.loc[gdf_high_res['NAME'] == country_name] # isolate row\n",
    "        country_geometry_high_res = country_gdf_high_res.geometry.iloc[0] # get multipolygon\n",
    "\n",
    "        # start variables for coordinate lists and counters\n",
    "        inside = []\n",
    "        outside_low_res = pd.DataFrame(columns=data.columns)\n",
    "        outside_high_res = []\n",
    "        inside_count = {}\n",
    "        outside_count = {}\n",
    "        total_count = 0\n",
    "\n",
    "        # check if it is in the low resolution file\n",
    "        for idx, row in data.iterrows():\n",
    "            location = Point(row['longitude'], row['latitude'])\n",
    "            total_count += 1\n",
    "            if location.within(country_geometry_buffer):\n",
    "                inside.append((row['ID'], row['latitude'], row['longitude']))\n",
    "                lat_long = (row['latitude'], row['longitude'])\n",
    "                inside_count[lat_long] = inside_count.get(lat_long, 0)+1\n",
    "            # add it to a temporary df if point is outside of low_res\n",
    "            else:\n",
    "                df_temporary = pd.DataFrame(data = [row], columns=outside_low_res.columns)\n",
    "                outside_low_res = pd.concat([outside_low_res, df_temporary], ignore_index=True)\n",
    "\n",
    "        # check for remaining points if they are in the high resolution file\n",
    "        for idx, row in outside_low_res.iterrows():\n",
    "            location = Point(row['longitude'], row['latitude'])\n",
    "            if location.within(country_geometry_high_res):\n",
    "                inside.append((row['ID'], row['latitude'], row['longitude']))\n",
    "                lat_long = (row['latitude'], row['longitude'])\n",
    "                inside_count[lat_long] = inside_count.get(lat_long, 0)+1\n",
    "                outside_low_res.drop(idx, inplace=True)\n",
    "            # add it to the list of coordinates outside of the zone\n",
    "            else:             \n",
    "                outside_high_res.append((row['ID'], row['latitude'], row['longitude']))\n",
    "                lat_long = (row['latitude'], row['longitude'])\n",
    "                outside_count[lat_long] = outside_count.get(lat_long, 0)+1\n",
    "\n",
    "        # save some outputs\n",
    "        invalid_LL_file_path = file_path.replace(f'{file_name}.html', 'invalid_LL.xlsx')\n",
    "        outside_low_res.to_excel(invalid_LL_file_path, index=False)\n",
    "        user_reporting_file_path = file_path.replace(f'{file_name}.html', 'user_reporting.txt')\n",
    "        total = len(inside) + len(outside_high_res)\n",
    "        percentage = (len(outside_high_res) / total) * 100\n",
    "        file = open(user_reporting_file_path, \"w\")\n",
    "        file.write(f'Total points inside: {len(inside)} \\n' \n",
    "                   f'Total points outside: {len(outside_high_res)} \\n' \n",
    "                   f'Total points: {total} \\n' \n",
    "                   f'Percentage of data outside: {percentage:.1f}% \\n' )\n",
    "        file.close()\n",
    "\n",
    "        plot_maps(data, country_geometry_high_res, map_output, inside, outside_high_res, inside_count, file_path, country_geometry_low_res)\n",
    "\n",
    "    else:\n",
    "        messagebox.showerror(title=\"empty fields\", message=\"there are empty fields, please go back and ensure all steps have been completed.\")\n",
    "        \n",
    "    \n",
    "def on_closing():\n",
    "    window.quit()\n",
    "    window.destroy()\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    \n",
    "    # create a window object\n",
    "    window=tkinter.Tk()\n",
    "    window.title('Coordinate Validation Tool')\n",
    "    window.geometry('448x400')\n",
    "    \n",
    "    # Create a canvas that fills the entire window\n",
    "    canvas = tkinter.Canvas(window)\n",
    "    canvas.pack(side=tkinter.LEFT, fill=tkinter.BOTH, expand=True)\n",
    "    frame = tkinter.Frame(canvas)\n",
    "    canvas.create_window(3, 0, window=frame)\n",
    "    def set_scroll_to_top(event):\n",
    "        canvas.yview_moveto(0)\n",
    "    canvas.bind(\"<Map>\", set_scroll_to_top)\n",
    "\n",
    "    # add a title\n",
    "    label = tkinter.Label(frame, text='This is the Coordinate Validation Tool. Follow the Below Steps').pack(pady=5)\n",
    "\n",
    "    # add a button to get the user to select the excel file\n",
    "    label = tkinter.Label(frame, text='    Step 1: Select the excel workbook containing the ID, lat and long coordinates').pack()\n",
    "    button = tkinter.Button(frame, text='Choose File', command = get_excel_doc).pack(pady=15)\n",
    "    \n",
    "    # add a button to get the user to select the shapefile at the low resolution\n",
    "    label = tkinter.Label(frame, text='Step 2: Select the appropriate low resolution shapefile for your data').pack()\n",
    "    button = tkinter.Button(frame, text='Choose File', command = get_shp_1).pack(pady=15)\n",
    "        \n",
    "    # add a button to get the user to select the shapefile at the high resolution\n",
    "    label = tkinter.Label(frame, text='Step 3: Select the appropriate high resolution shapefile for your data').pack()\n",
    "    button = tkinter.Button(frame, text='Choose File', command = get_shp_2).pack(pady=15)\n",
    "    \n",
    "    # add a listbox to get user to select country, add scrollbar and confirm button\n",
    "    label = tkinter.Label(frame, text='Step 4: Select the country, then hit confirm').pack()\n",
    "    listbox_frame = tkinter.Frame(frame)\n",
    "    listbox_frame.pack()\n",
    "    listvar = tkinter.StringVar(value=['Cuba', 'Bahamas', 'Bermuda', 'Brazil', 'Dominican Republic', 'Haiti', 'El Salvador', 'Guatemala', 'Costa Rica', 'Colombia', 'Turkey', 'Trinidad and Tobago', 'Grenada', 'Barbados', 'Saint Lucia', 'Dominica', 'Antigua and Barbuda', 'Saint Kitts and Nevis', 'Anguilla', 'Jamaica', 'Peru', 'Nicaragua', 'Argentina', 'Curacao', 'Aruba', 'U.S. Virgin Islands', 'Saint Barthelemy', 'Puerto Rico', 'Cayman Islands', 'Bolivia', 'Saint Martin', 'Suriname', 'Paraguay', 'Montserrat', 'Malta', 'Portugal'])\n",
    "    listbox = tkinter.Listbox(listbox_frame, listvariable=listvar, height=5)\n",
    "    listbox.grid(row=0, column=0)\n",
    "    scrollbar = tkinter.Scrollbar(listbox_frame, orient=tkinter.VERTICAL, command=listbox.yview)\n",
    "    scrollbar.grid(row=0, column=1, sticky=tkinter.NS)\n",
    "    button = tkinter.Button(frame, text='Confirm', command=choose_country).pack(pady=15)\n",
    "\n",
    "    # add a listbox to get user to select output, add scrollbar and confirm button\n",
    "    label = tkinter.Label(frame, text='Step 5: Select the output map, then hit confirm').pack()\n",
    "    listbox_frame2 = tkinter.Frame(frame)\n",
    "    listbox_frame2.pack()\n",
    "    listvar2 = tkinter.StringVar(listbox_frame2, value= ['Heatmap', 'Heatmap Overlap', 'Point Data Map', 'All'])\n",
    "    listbox_frame = tkinter.Frame(frame)\n",
    "    listbox_frame.pack()\n",
    "    listbox2 = tkinter.Listbox(listbox_frame, listvariable=listvar2, height=4)\n",
    "    listbox2.pack()\n",
    "    button = tkinter.Button(frame, text='Confirm', command=choose_output)\n",
    "    button.pack(pady=15)\n",
    "    \n",
    "    # add a button to get the desired file name\n",
    "    label = tkinter.Label(frame, text='Step 6: Choose the name you want to save the file in').pack()\n",
    "    textentry_file = tkinter.Entry(frame)\n",
    "    textentry_file.pack()\n",
    "    button = tkinter.Button(frame, text='Confirm', command = get_file_name).pack(pady=15)\n",
    "    \n",
    "    # add a button get the user to select the destination folder\n",
    "    label = tkinter.Label(frame, text='Step 7: Select the folder you would like your outputs saved to').pack()\n",
    "    button = tkinter.Button(frame, text='Choose Folder', command = get_file_path).pack(pady=15)\n",
    "    \n",
    "    # start analysis\n",
    "    label = tkinter.Label(frame, text='Step 8: Start Analysis').pack()\n",
    "    button = tkinter.Button(frame, text='Go', command = geospatial_analysis).pack()\n",
    "    label = tkinter.Label(frame, text='').pack(pady=15)\n",
    "\n",
    "    # Add a scrollbar to the window\n",
    "    def configure_scroll_region(event):\n",
    "        canvas.configure(scrollregion=canvas.bbox(\"all\"))\n",
    "    frame.bind(\"<Configure>\", configure_scroll_region)\n",
    "    scrollbar = tkinter.Scrollbar(window, orient=tkinter.VERTICAL, command=canvas.yview)\n",
    "    scrollbar.pack(side=tkinter.RIGHT, fill=tkinter.Y)\n",
    "    canvas.configure(yscrollcommand=scrollbar.set)\n",
    "    \n",
    "    window.protocol(\"WM_DELETE_WINDOW\", on_closing)\n",
    "    window.mainloop()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6ff19691",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5159423b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
